package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io"
	"log"
	"os"
	"reflect"
	"strconv"
	"strings"
)

func parse(filename, pkg string, writer io.StringWriter) error {
	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, filename, nil, 0)
	if err != nil {
		return err
	}

	writer.WriteString("// Code generated by argsgen.\n")
	writer.WriteString("// DO NOT EDIT!\n\n")
	writer.WriteString("package " + pkg)
	writer.WriteString("\n\n")
	writer.WriteString(`import "flag"`)
	writer.WriteString("\n\n")

	var structName string
	positional := make(map[int][]string)

	ast.Inspect(f, func(n ast.Node) bool {
		switch x := n.(type) {
		case *ast.TypeSpec:
			structName = x.Name.Name
		case *ast.StructType:
			writer.WriteString(fmt.Sprintf("func (o *%s) Parse() {\n", structName))
			for _, field := range x.Fields.List {
				var varFunc string
				switch t := field.Type.(*ast.Ident).Name; t {
				case "string", "bool", "uint", "int":
					varFunc = fmt.Sprintf("%sVar", strings.Title(t))
				default:
					panic("type not supported " + t)
				}
				var tag string
				if field.Tag != nil {
					tagString, _ := strconv.Unquote(field.Tag.Value)
					tag = reflect.StructTag(tagString).Get(("arg"))
					options := strings.Split(tag, ",")
					if len(options) > 1 && options[1] == "+" {
						tag = options[0]
						n := len(positional)
						for _, name := range field.Names {
							positional[n] = append(positional[n], name.String())
						}
					}
				}
				for _, name := range field.Names {
					writer.WriteString("\t")
					writer.WriteString(fmt.Sprintf(`flag.%s(&o.%s, "%s", o.%s, "%s")`, varFunc, name, name, field.Names[0].Name, tag))
					writer.WriteString("\n")
				}

			}
			writer.WriteString("\tflag.Parse()\n\n")
			writer.WriteString("\tnarg := flag.NArg()\n")
			writer.WriteString("\tif narg == 0 {\n")
			writer.WriteString("\t\treturn\n")
			writer.WriteString("\t}\n")
			writer.WriteString(fmt.Sprintf("\tif narg != %d {\n", len(positional)))
			writer.WriteString("\t\tpanic(\"not enough positional arguments found\")\n")
			writer.WriteString("\t}\n\n")

			for i, fields := range positional {
				for _, field := range fields {
					writer.WriteString(fmt.Sprintf("\to.%s = flag.Arg(%d)\n", field, i))
				}
			}

			writer.WriteString("}\n")

			return false
		}
		return true
	})

	return nil
}

func main() {
	input := os.Getenv("GOFILE")
	pkg := os.Getenv("GOPACKAGE")
	builder := new(strings.Builder)

	if err := parse(input, pkg, builder); err != nil {
		log.Fatal(err)
	}

	output := strings.TrimSuffix(input, ".go") + "_gen.go"
	file, err := os.Create(output)
	if err != nil {
		log.Fatal(err)
	}
	defer file.Close()

	file.WriteString(builder.String())
}
